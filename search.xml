<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2024/04/15/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volitile关键字用于解决多线程并发执行时可能出现的<strong>可见性</strong>问题<br><a name="sYfCx"></a></p>
<h2 id="缓存锁定"><a href="#缓存锁定" class="headerlink" title="缓存锁定"></a>缓存锁定</h2><p>处理器在对已经加载到cache当中的共享数据进行修改时，会向总线发出命令，其他处理器通过<strong>嗅探总线</strong>发现有处理器请求写内存地址，而该内存地址为共享地址，处理器就会使存有该共享内存地址的cache行失效。<strong>处理器修改完共享数据后，会将结果写回内存</strong>。这样，其他处理器下次对共享数据的操作就会先从主存当中读取该数据到cache中，然后再进行处理，这样得到的就是最新的数据，避免了可见性问题。</p>
<p>根据书中所写，对加了volatile关键字的变量进行读写操作时，生成的汇编代码前会加上lock。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712825586089-1e04ea3b-f99d-40d0-9cf5-2fe53d1f7a8d.png#averageHue=%23f4f4f4&clientId=u8c18e190-44d9-4&from=paste&height=471&id=u37db334b&originHeight=707&originWidth=1317&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=88284&status=done&style=none&taskId=u76a5e643-befd-42f8-b362-331480c4c35&title=&width=878" alt="image.png"><br />于是，我写了这样一段demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        temp++;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">bottle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">        bottle.price++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Goods()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过javac以及javap命令在终端查看它编译后的汇编代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -g:none -d out src/test.java</span><br><span class="line">javap -c -v -p out/test.class &gt; out/test.asm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到的汇编文件中关键代码部分如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  static volatile int temp;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0048) ACC_STATIC, ACC_VOLATILE</span><br><span class="line"></span><br><span class="line">  public test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: getstatic     #7                  // Field temp:I</span><br><span class="line">         3: iconst_1</span><br><span class="line">         4: iadd</span><br><span class="line">         5: putstatic     #7                  // Field temp:I</span><br><span class="line">         8: new           #13                 // class Goods</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #15                 // Method Goods.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_1</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: dup</span><br><span class="line">        18: getfield      #16                 // Field Goods.price:I</span><br><span class="line">        21: iconst_1</span><br><span class="line">        22: iadd</span><br><span class="line">        23: putfield      #16                 // Field Goods.price:I</span><br><span class="line">        26: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0008) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: putstatic     #7                  // Field temp:I</span><br><span class="line">         5: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没有找到带有lock前缀的汇编指令，于是我去求助了一下gpt，得到的解答如下<br />当你查看 Java 代码编译后的汇编代码时，如果发现加了 volatile 的变量对应的汇编语句没有出现 lock 前缀，可能有以下几个原因：</p>
<ol>
<li><strong>编译器优化</strong>：编译器在生成汇编代码时可能会进行优化，将 volatile 变量的读写操作优化为更高效的方式，而不是简单地添加 lock 前缀。</li>
<li><strong>硬件层面支持</strong>：某些处理器对 volatile 变量的操作可能有硬件层面的支持，因此在汇编代码中不需要显式添加 lock。</li>
<li><strong>汇编代码层面隐藏</strong>：lock 前缀可能被隐藏在汇编代码的更底层的指令中，不一定会直接出现在你查看的汇编代码中。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>【zookeeper】安装</title>
    <url>/2024/04/15/%E3%80%90zookeeper%E3%80%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="1-Apache-Zookeeper官网下载"><a href="#1-Apache-Zookeeper官网下载" class="headerlink" title="1. Apache Zookeeper官网下载"></a>1. Apache Zookeeper官网下载</h1><p> <img src="https://img-blog.csdnimg.cn/direct/418b195344d64e3bac8b3e1e83a990bd.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/direct/aa9ade8dd3494fe5bec65b6bba4b2efc.png" alt="在这里插入图片描述"></p>
<h1 id="2-解压后创建log和data文件夹"><a href="#2-解压后创建log和data文件夹" class="headerlink" title="2. 解压后创建log和data文件夹"></a>2. 解压后创建log和data文件夹</h1><p><img src="https://img-blog.csdnimg.cn/direct/8280b972b4924e3d8b96dd66afeeda58.png" alt="在这里插入图片描述">这个其实不一定要建在zookeeper文件夹下，建在任意一个文件夹里都行，只要配置文件中的路径配置能找到就行</p>
<h1 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h1><p><img src="https://img-blog.csdnimg.cn/direct/e4851cb2ab7849278a595578f18547ed.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/direct/31200127e35c430faa8eb696a9932a06.png" alt="在这里插入图片描述"><br><strong>这里要注意！！！<br>win系统下路径分隔符用</strong></p>
<blockquote>
<p>&#x2F;</p>
</blockquote>
<p>有点疑问：为什么win系统磁盘中文件的绝对路径的分隔符是\，但在配置文件中文件路径的分隔符要用&#x2F;？</p>
<p>查询后得出结论：</p>
<blockquote>
<p>在Windows操作系统中，文件路径的绝对路径分隔符是反斜杠\，这是因为反斜杠在Windows系统中被用作文件路径分隔符的标准约定。例如，C:\Users\Admin\Desktop\file.txt 是Windows系统中文件的绝对路径表示方式。<br>而在配置文件中，特别是在类Unix系统（如Linux、MacOS等）中，文件路径的分隔符是正斜杠&#x2F;。<strong>这是因为Unix系统中的路径分隔符是正斜杠，而且正斜杠在配置文件中通常用作路径分隔符的约定</strong>。所以，即使在Windows系统中使用的是反斜杠作为文件路径分隔符，<strong>但在配置文件中为了与Unix系统的约定保持一致，通常会使用正斜杠作为文件路径分隔符</strong>。<br>因此，为了确保在不同操作系统和不同环境下都能正确解析文件路径，通常会建议在配置文件中使用正斜杠&#x2F;作为文件路径的分隔符。这样可以避免在不同系统下出现路径解析错误的情况，保证程序的可移植性和通用性。</p>
</blockquote>
<h1 id="4-启动zookeeper"><a href="#4-启动zookeeper" class="headerlink" title="4.启动zookeeper"></a>4.启动zookeeper</h1><p><img src="https://img-blog.csdnimg.cn/direct/8d59d2ed4f2c41bbaad96e76dc3f72cf.png" alt="在这里插入图片描述"></p>
<ol>
<li>zkServer.cmd正常启动如下<br> <img src="https://img-blog.csdnimg.cn/direct/cf0dc33f4e8f4ff98404c6c118b273ba.png" alt="在这里插入图片描述"><br> 如遇闪退，可以在zkServer.cmd文件末尾加上<strong>pause</strong>，以便查看报错原因<br><img src="https://img-blog.csdnimg.cn/direct/b0793acefc6b40f4a037bc2a464b3973.png" alt="在这里插入图片描述"></li>
<li>zkCli.cmd正常启动如下<br> <img src="https://img-blog.csdnimg.cn/direct/c0837d2551f54976af44692ffb48f8ca.png" alt="在这里插入图片描述"><br>至此，zookeeper启动成功</li>
</ol>
<p><strong>安装过程中遇到过许多问题，感谢将这些问题解决过程分享出来的同路人们！</strong></p>
<p>希望这篇文章能帮到你~</p>
]]></content>
  </entry>
  <entry>
    <title>线程的创建和启动</title>
    <url>/2024/04/15/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><a name="Kh76L"></a></p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程主要通过继承类和实现接口来完成<br><a name="go9bC"></a></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>需要重写Thread类中的run（）方法<br><a name="SE0Wj"></a></p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现接口中的run（）方法<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712886633895-e42885b6-7a11-4e59-b054-1a5707eefdec.png#averageHue=%2395754d&clientId=u704e08d6-349d-4&from=paste&height=425&id=u38ae8a0f&originHeight=638&originWidth=982&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=75363&status=done&style=none&taskId=uca06737c-96d9-4311-9883-ceeabffe8d3&title=&width=654.6666666666666" alt="image.png"><br><a name="HbiB1"></a></p>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>需要实现接口中的call（）方法，通过这种方式创建的线程，可以有返回值<V><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712886681775-f4ffd171-2477-4829-8b6c-f2c3b9538841.png#averageHue=%232d2d2c&clientId=u704e08d6-349d-4&from=paste&height=533&id=ua80a6765&originHeight=799&originWidth=1482&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=117534&status=done&style=none&taskId=ua069e242-2fd0-4b16-a5a9-64e1bdd5146&title=&width=988" alt="image.png"><br><a name="s8v8x"></a></p>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>通过start（）方法启动线程<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712886832645-b1eeaf04-2f51-4292-8e90-ed624166e687.png#averageHue=%232e2d2c&clientId=u704e08d6-349d-4&from=paste&height=467&id=uf014195e&originHeight=701&originWidth=1241&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=89740&status=done&style=none&taskId=ud25365b8-fd92-4087-9c2f-1c897f56d54&title=&width=827.3333333333334" alt="image.png"><br />阅读start（）源码，探究一下底层实现<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712887308648-6dde3003-e9ee-4b4d-aea3-4d723e3dc793.png#averageHue=%232d2c2c&clientId=u704e08d6-349d-4&from=paste&height=637&id=u5202ce7c&originHeight=956&originWidth=1714&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=200804&status=done&style=none&taskId=u7cd89f12-e3a3-4b48-8f72-ac4dfe5cdf9&title=&width=1142.6666666666667" alt="image.png"><br />再看看start0（）做了些啥<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712887350747-0ba96ff6-ae0e-49fa-9348-a33b6622ec2a.png#averageHue=%232c2c2b&clientId=u704e08d6-349d-4&from=paste&height=226&id=u888f856d&originHeight=339&originWidth=1195&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=36940&status=done&style=none&taskId=u4923b776-90bd-404f-9586-58e3200d1f8&title=&width=796.6666666666666" alt="image.png"><br />start0（）是被native修饰的方法，说明它是由外部语言（C&#x2F;C++）来实现的，而不是通过JVM虚拟机来执行<br />所以，那具体做了啥呢？<br />（未完，待定）</p>
]]></content>
  </entry>
  <entry>
    <title>线程的状态</title>
    <url>/2024/04/15/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<hr>
<p>与操作系统线程的状态定义不同，Java线程中的状态有6种，各自对应不同的操作系统中的线程状态<br><a name="GWG7A"></a></p>
<h1 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h1><p>调用start（）方法之前，对应于操作系统线程的启动态<br><a name="nJaTf"></a></p>
<h1 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h1><p>调用start（）方法之后，对应于操作系统线程的就绪态&#x2F;运行态<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712981543133-34f400d0-202d-4e31-b48d-564bc128c08a.png#averageHue=%232e2d2c&clientId=u463b2391-e066-4&from=paste&height=596&id=ucb92ced2&originHeight=894&originWidth=1230&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131136&status=done&style=none&taskId=u0120c266-01f5-4432-986c-81aeab8ddfa&title=&width=820" alt="image.png"></p>
<p><a name="AbcZk"></a></p>
<h1 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h1><p>线程请求资源未能得到满足，对应于操作系统线程的阻塞态<br><a name="DlXdF"></a></p>
<h1 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h1><p>调用Thread.wait()，Thread.join()方法之后，对应于操作系统线程的挂起态<br />需要有其他线程来唤醒它<br><a name="gHUY3"></a></p>
<h1 id="TIME-WAITING"><a href="#TIME-WAITING" class="headerlink" title="TIME-WAITING"></a>TIME-WAITING</h1><p>调用Thread.sleep(long millis)、Thread.join(long millis)方法之后，对应于操作系统线程的挂起态<br />可以自动唤醒<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/43333018/1712977925658-88e6dcfd-87da-4dd9-87fb-a0fe8a6d3687.png#averageHue=%232c2b2b&clientId=u463b2391-e066-4&from=paste&height=177&id=uc65db5c6&originHeight=265&originWidth=1369&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=48652&status=done&style=none&taskId=u5dd6500d-c0e8-488b-800a-84146768b8d&title=&width=912.6666666666666" alt="image.png"><br><a name="ne74J"></a></p>
<h1 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h1><h2 id=""><a href="#" class="headerlink" title=""></a><a name="qrcG4"></a></h2>]]></content>
  </entry>
</search>
